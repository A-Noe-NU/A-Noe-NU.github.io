!function(t){function n(I){if(g[I])return g[I].exports;var c=g[I]={i:I,l:!1,exports:{}};return t[I].call(c.exports,c,c.exports,n),c.l=!0,c.exports}var g={};n.m=t,n.c=g,n.i=function(t){return t},n.d=function(t,g,I){n.o(t,g)||Object.defineProperty(t,g,{configurable:!1,enumerable:!0,get:I})},n.n=function(t){var g=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(g,"a",g),g},n.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},n.p="",n(n.s=0)}([function(module,exports,__webpack_require__){"use strict";eval("\n\nvar width = window.innerWidth;\nvar height = window.innerHeight;\n\nfunction main(regl, citiesData, imgData) {\n  var numPoints = 100000;\n  var pointWidth = 4;\n  var pointMargin = 1;\n  var duration = 1500;\n  var delayByIndex = 500 / numPoints;\n  var maxDuration = duration + delayByIndex * numPoints; // include max delay in here\n\n  var toCities = function toCities(points) {\n    return citiesLayout(points, width, height, citiesData);\n  };\n  var toBars = function toBars(points) {\n    return barsLayout(points, width, height, citiesData);\n  };\n  var toSwarm = function toSwarm(points) {\n    return swarmLayout(points, width, height, citiesData);\n  };\n  var toPhoto = function toPhoto(points) {\n    return photoLayout(points, width, height, imgData);\n  };\n  var toArea = function toArea(points) {\n    return areaLayout(points, width, height, citiesData);\n  };\n  var toPhyllotaxis = function toPhyllotaxis(points) {\n    return phyllotaxisLayout(points, pointWidth, width / 2, height / 2, citiesData);\n  };\n  var toMiddle = function toMiddle(points) {\n    points.forEach(function (d, i) {\n      d.x = width / 2;\n      d.y = height / 2;\n      d.color = [0, 0, 0];\n    });\n  };\n  var toBlack = function toBlack(points) {\n    points.forEach(function (d, i) {\n      d.color = [0, 0, 0];\n    });\n  };\n\n  var layouts = [toPhyllotaxis, toCities, toArea, toBars, toPhoto, toBlack];\n  var currentLayout = 0;\n\n  // wrap d3 color scales so they produce vec3s with values 0-1\n  // also limit the t value to remove darkest color\n  function wrapColorScale(scale) {\n    var tScale = d3.scaleLinear().domain([0, 1]).range([0.4, 1]);\n    return function (t) {\n      var rgb = d3.rgb(scale(tScale(t)));\n      return [rgb.r / 255, rgb.g / 255, rgb.b / 255];\n    };\n  }\n\n  var colorScales = [d3.scaleSequential(d3.interpolateViridis), d3.scaleSequential(d3.interpolateMagma), d3.scaleSequential(d3.interpolateInferno), d3.scaleSequential(d3.interpolateCool)].map(wrapColorScale);\n  var currentColorScale = 0;\n\n  // function to compile a draw points regl func\n  function createDrawPoints(points) {\n    var drawPoints = regl({\n      frag: '\\n\\t\\t  precision highp float;\\n\\t\\t\\tvarying vec3 fragColor;\\n\\t\\t\\tvoid main() {\\n\\t\\t\\t\\tgl_FragColor = vec4(fragColor, 1);\\n\\t\\t\\t}\\n\\t\\t\\t',\n\n      vert: '\\n\\t\\t\\tattribute vec2 positionStart;\\n\\t\\t\\tattribute vec2 positionEnd;\\n\\t\\t\\tattribute float index;\\n\\t\\t\\tattribute vec3 colorStart;\\n\\t\\t\\tattribute vec3 colorEnd;\\n\\n\\t\\t\\tvarying vec3 fragColor;\\n\\n\\t\\t\\tuniform float pointWidth;\\n\\t\\t\\tuniform float stageWidth;\\n\\t\\t\\tuniform float stageHeight;\\n\\t\\t\\tuniform float elapsed;\\n\\t\\t\\tuniform float duration;\\n\\t\\t\\tuniform float delayByIndex;\\n\\t\\t\\t// uniform float tick;\\n\\t\\t\\t// uniform float animationRadius;\\n\\t\\t\\tuniform float numPoints;\\n\\n\\t\\t\\t// helper function to transform from pixel space to normalized device coordinates (NDC)\\n\\t\\t\\t// in NDC (0,0) is the middle, (-1, 1) is the top left and (1, -1) is the bottom right.\\n\\t\\t\\tvec2 normalizeCoords(vec2 position) {\\n\\t\\t\\t\\t// read in the positions into x and y vars\\n\\t      float x = position[0];\\n\\t      float y = position[1];\\n\\n\\t\\t\\t\\treturn vec2(\\n\\t\\t      2.0 * ((x / stageWidth) - 0.5),\\n\\t\\t      // invert y since we think [0,0] is bottom left in pixel space\\n\\t\\t      -(2.0 * ((y / stageHeight) - 0.5)));\\n\\t\\t\\t}\\n\\n\\t\\t\\t// helper function to handle cubic easing (copied from d3 for consistency)\\n\\t\\t\\t// note there are pre-made easing functions available via glslify.\\n\\t\\t\\tfloat easeCubicInOut(float t) {\\n\\t\\t\\t\\tt *= 2.0;\\n        t = (t <= 1.0 ? t * t * t : (t -= 2.0) * t * t + 2.0) / 2.0;\\n\\n        if (t > 1.0) {\\n          t = 1.0;\\n        }\\n\\n        return t;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main() {\\n\\t\\t\\t\\tgl_PointSize = pointWidth;\\n\\n\\t\\t\\t\\tfloat delay = delayByIndex * index;\\n\\t      float t;\\n\\n\\t      // drawing without animation, so show end state immediately\\n\\t      if (duration == 0.0) {\\n\\t        t = 1.0;\\n\\n\\t      // still delaying before animating\\n\\t      } else if (elapsed < delay) {\\n\\t        t = 0.0;\\n\\t      } else {\\n\\t        t = easeCubicInOut((elapsed - delay) / duration);\\n\\t      }\\n\\n\\t      // interpolate position\\n\\t      vec2 position = mix(positionStart, positionEnd, t);\\n\\n\\t      // apply an ambient animation\\n\\t\\t\\t\\t// float dir = index > numPoints / 2.0 ? 1.0 : -1.0;\\n\\t      // position[0] += animationRadius * cos((tick + index) * dir);\\n\\t      // position[1] += animationRadius * sin((tick + index) * dir);\\n\\n\\t      // above we + index to offset how they move\\n\\t      // we multiply by dir to change CW vs CCW for half\\n\\n\\n\\t      // interpolate color\\n\\t      fragColor = mix(colorStart, colorEnd, t);\\n\\n\\t      // scale to normalized device coordinates\\n\\t\\t\\t\\t// gl_Position is a special variable that holds the position of a vertex\\n\\t      gl_Position = vec4(normalizeCoords(position), 0.0, 1.0);\\n\\t\\t\\t}\\n\\t\\t\\t',\n\n      attributes: {\n        positionStart: points.map(function (d) {\n          return [d.sx, d.sy];\n        }),\n        positionEnd: points.map(function (d) {\n          return [d.tx, d.ty];\n        }),\n        colorStart: points.map(function (d) {\n          return d.colorStart;\n        }),\n        colorEnd: points.map(function (d) {\n          return d.colorEnd;\n        }),\n        index: d3.range(points.length)\n      },\n\n      uniforms: {\n        pointWidth: regl.prop('pointWidth'),\n        stageWidth: regl.prop('stageWidth'),\n        stageHeight: regl.prop('stageHeight'),\n        delayByIndex: regl.prop('delayByIndex'),\n        duration: regl.prop('duration'),\n        numPoints: numPoints,\n        // animationRadius: 0,// 15.0,\n        // tick: (reglprops) => { // increase multiplier for faster animation speed\n        // \t// console.log(reglprops);\n        // \t// return reglprops.tick / 50;\n        // \treturn 0; // disable ambient animation\n        // },\n        // time in milliseconds since the prop startTime (i.e. time elapsed)\n        elapsed: function elapsed(_ref, _ref2) {\n          var time = _ref.time;\n          var _ref2$startTime = _ref2.startTime,\n              startTime = _ref2$startTime === undefined ? 0 : _ref2$startTime;\n          return (time - startTime) * 1000;\n        }\n      },\n\n      count: points.length,\n      primitive: 'points'\n    });\n\n    return drawPoints;\n  }\n\n  // function to start animation loop (note: time is in seconds)\n  function animate(layout, points) {\n    console.log('animating with new layout');\n    // make previous end the new beginning\n    points.forEach(function (d) {\n      d.sx = d.tx;\n      d.sy = d.ty;\n      d.colorStart = d.colorEnd;\n    });\n\n    // layout points\n    layout(points);\n\n    // copy layout x y to end positions\n    var colorScale = colorScales[currentColorScale];\n    points.forEach(function (d, i) {\n      d.tx = d.x;\n      d.ty = d.y;\n      // d.colorEnd = colorScale(i / points.length)\n      d.colorEnd = d.color;\n    });\n\n    // create the regl function with the new start and end points\n    var drawPoints = createDrawPoints(points);\n\n    // start an animation loop\n    var startTime = null; // in seconds\n    var frameLoop = regl.frame(function (_ref3) {\n      var time = _ref3.time;\n\n      // keep track of start time so we can get time elapsed\n      // this is important since time doesn't reset when starting new animations\n      if (startTime === null) {\n        startTime = time;\n      }\n\n      // clear the buffer\n      regl.clear({\n        // background color (black)\n        color: [0, 0, 0, 1],\n        depth: 1\n      });\n\n      // draw the points using our created regl func\n      // note that the arguments are available via `regl.prop`.\n      drawPoints({\n        pointWidth: pointWidth,\n        stageWidth: width,\n        stageHeight: height,\n        duration: duration,\n        delayByIndex: delayByIndex,\n        startTime: startTime\n      });\n\n      // how long to stay at a final frame before animating again (in seconds)\n      var delayAtEnd = 0.1;\n\n      // if we have exceeded the maximum duration, move on to the next animation\n      if (time - startTime > maxDuration / 1000 + delayAtEnd) {\n        console.log('done animating, moving to next layout');\n\n        frameLoop.cancel();\n        currentLayout = (currentLayout + 1) % layouts.length;\n        currentColorScale = (currentColorScale + 1) % colorScales.length;\n\n        // when restarting at the beginning, come back from the middle again\n        if (currentLayout === 0) {\n          points.forEach(function (d, i) {\n            d.tx = width / 2;\n            d.ty = height / 2;\n            d.colorEnd = [0, 0, 0];\n          });\n        }\n\n        animate(layouts[currentLayout], points);\n      }\n    });\n  }\n\n  // create initial set of points\n  var points = d3.range(numPoints).map(function (d) {\n    return {};\n  });\n\n  points.forEach(function (d, i) {\n    d.tx = width / 2;\n    d.ty = height / 2;\n    d.colorEnd = [0, 0, 0];\n  });\n\n  // start animation loop\n  animate(layouts[currentLayout], points);\n}\n\nloadData(width, height).then(function (_ref4) {\n  var citiesData = _ref4.citiesData,\n      imgData = _ref4.imgData;\n\n  console.log('data has loaded. initializing regl...');\n\n  // initialize regl\n  createREGL({\n    // callback when regl is initialized\n    onDone: function onDone(err, regl) {\n      if (err) {\n        console.error('Error initializing regl', err);\n        return;\n      }\n      main(regl, citiesData, imgData);\n    }\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zY3JpcHQuanM/OWE5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuY29uc3QgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG5mdW5jdGlvbiBtYWluKHJlZ2wsIGNpdGllc0RhdGEsIGltZ0RhdGEpIHtcbiAgY29uc3QgbnVtUG9pbnRzID0gMTAwMDAwO1xuICBjb25zdCBwb2ludFdpZHRoID0gNDtcbiAgY29uc3QgcG9pbnRNYXJnaW4gPSAxO1xuICBjb25zdCBkdXJhdGlvbiA9IDE1MDA7XG4gIGNvbnN0IGRlbGF5QnlJbmRleCA9IDUwMCAvIG51bVBvaW50cztcbiAgY29uc3QgbWF4RHVyYXRpb24gPSBkdXJhdGlvbiArIGRlbGF5QnlJbmRleCAqIG51bVBvaW50czsgLy8gaW5jbHVkZSBtYXggZGVsYXkgaW4gaGVyZVxuXG4gIGNvbnN0IHRvQ2l0aWVzID0gcG9pbnRzID0+IGNpdGllc0xheW91dChwb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNpdGllc0RhdGEpO1xuICBjb25zdCB0b0JhcnMgPSBwb2ludHMgPT4gYmFyc0xheW91dChwb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNpdGllc0RhdGEpO1xuICBjb25zdCB0b1N3YXJtID0gcG9pbnRzID0+IHN3YXJtTGF5b3V0KHBvaW50cywgd2lkdGgsIGhlaWdodCwgY2l0aWVzRGF0YSk7XG4gIGNvbnN0IHRvUGhvdG8gPSBwb2ludHMgPT4gcGhvdG9MYXlvdXQocG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBpbWdEYXRhKTtcbiAgY29uc3QgdG9BcmVhID0gcG9pbnRzID0+IGFyZWFMYXlvdXQocG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBjaXRpZXNEYXRhKTtcbiAgY29uc3QgdG9QaHlsbG90YXhpcyA9IHBvaW50cyA9PlxuICAgIHBoeWxsb3RheGlzTGF5b3V0KHBvaW50cywgcG9pbnRXaWR0aCwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCBjaXRpZXNEYXRhKTtcbiAgY29uc3QgdG9NaWRkbGUgPSBwb2ludHMgPT4ge1xuICAgIHBvaW50cy5mb3JFYWNoKChkLCBpKSA9PiB7XG4gICAgICBkLnggPSB3aWR0aCAvIDI7XG4gICAgICBkLnkgPSBoZWlnaHQgLyAyO1xuICAgICAgZC5jb2xvciA9IFswLCAwLCAwXTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdG9CbGFjayA9IHBvaW50cyA9PiB7XG4gICAgcG9pbnRzLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgIGQuY29sb3IgPSBbMCwgMCwgMF07XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgbGF5b3V0cyA9IFt0b1BoeWxsb3RheGlzLCB0b0NpdGllcywgdG9BcmVhLCB0b0JhcnMsIHRvUGhvdG8sIHRvQmxhY2tdO1xuICBsZXQgY3VycmVudExheW91dCA9IDA7XG5cbiAgLy8gd3JhcCBkMyBjb2xvciBzY2FsZXMgc28gdGhleSBwcm9kdWNlIHZlYzNzIHdpdGggdmFsdWVzIDAtMVxuICAvLyBhbHNvIGxpbWl0IHRoZSB0IHZhbHVlIHRvIHJlbW92ZSBkYXJrZXN0IGNvbG9yXG4gIGZ1bmN0aW9uIHdyYXBDb2xvclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgdFNjYWxlID0gZDNcbiAgICAgIC5zY2FsZUxpbmVhcigpXG4gICAgICAuZG9tYWluKFswLCAxXSlcbiAgICAgIC5yYW5nZShbMC40LCAxXSk7XG4gICAgcmV0dXJuIHQgPT4ge1xuICAgICAgY29uc3QgcmdiID0gZDMucmdiKHNjYWxlKHRTY2FsZSh0KSkpO1xuICAgICAgcmV0dXJuIFtyZ2IuciAvIDI1NSwgcmdiLmcgLyAyNTUsIHJnYi5iIC8gMjU1XTtcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgY29sb3JTY2FsZXMgPSBbXG4gICAgZDMuc2NhbGVTZXF1ZW50aWFsKGQzLmludGVycG9sYXRlVmlyaWRpcyksXG4gICAgZDMuc2NhbGVTZXF1ZW50aWFsKGQzLmludGVycG9sYXRlTWFnbWEpLFxuICAgIGQzLnNjYWxlU2VxdWVudGlhbChkMy5pbnRlcnBvbGF0ZUluZmVybm8pLFxuICAgIGQzLnNjYWxlU2VxdWVudGlhbChkMy5pbnRlcnBvbGF0ZUNvb2wpLFxuICBdLm1hcCh3cmFwQ29sb3JTY2FsZSk7XG4gIGxldCBjdXJyZW50Q29sb3JTY2FsZSA9IDA7XG5cbiAgLy8gZnVuY3Rpb24gdG8gY29tcGlsZSBhIGRyYXcgcG9pbnRzIHJlZ2wgZnVuY1xuICBmdW5jdGlvbiBjcmVhdGVEcmF3UG9pbnRzKHBvaW50cykge1xuICAgIGNvbnN0IGRyYXdQb2ludHMgPSByZWdsKHtcbiAgICAgIGZyYWc6IGBcblx0XHQgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcblx0XHRcdHZhcnlpbmcgdmVjMyBmcmFnQ29sb3I7XG5cdFx0XHR2b2lkIG1haW4oKSB7XG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQoZnJhZ0NvbG9yLCAxKTtcblx0XHRcdH1cblx0XHRcdGAsXG5cbiAgICAgIHZlcnQ6IGBcblx0XHRcdGF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uU3RhcnQ7XG5cdFx0XHRhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbkVuZDtcblx0XHRcdGF0dHJpYnV0ZSBmbG9hdCBpbmRleDtcblx0XHRcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yU3RhcnQ7XG5cdFx0XHRhdHRyaWJ1dGUgdmVjMyBjb2xvckVuZDtcblxuXHRcdFx0dmFyeWluZyB2ZWMzIGZyYWdDb2xvcjtcblxuXHRcdFx0dW5pZm9ybSBmbG9hdCBwb2ludFdpZHRoO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCBzdGFnZVdpZHRoO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCBzdGFnZUhlaWdodDtcblx0XHRcdHVuaWZvcm0gZmxvYXQgZWxhcHNlZDtcblx0XHRcdHVuaWZvcm0gZmxvYXQgZHVyYXRpb247XG5cdFx0XHR1bmlmb3JtIGZsb2F0IGRlbGF5QnlJbmRleDtcblx0XHRcdC8vIHVuaWZvcm0gZmxvYXQgdGljaztcblx0XHRcdC8vIHVuaWZvcm0gZmxvYXQgYW5pbWF0aW9uUmFkaXVzO1xuXHRcdFx0dW5pZm9ybSBmbG9hdCBudW1Qb2ludHM7XG5cblx0XHRcdC8vIGhlbHBlciBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gZnJvbSBwaXhlbCBzcGFjZSB0byBub3JtYWxpemVkIGRldmljZSBjb29yZGluYXRlcyAoTkRDKVxuXHRcdFx0Ly8gaW4gTkRDICgwLDApIGlzIHRoZSBtaWRkbGUsICgtMSwgMSkgaXMgdGhlIHRvcCBsZWZ0IGFuZCAoMSwgLTEpIGlzIHRoZSBib3R0b20gcmlnaHQuXG5cdFx0XHR2ZWMyIG5vcm1hbGl6ZUNvb3Jkcyh2ZWMyIHBvc2l0aW9uKSB7XG5cdFx0XHRcdC8vIHJlYWQgaW4gdGhlIHBvc2l0aW9ucyBpbnRvIHggYW5kIHkgdmFyc1xuXHQgICAgICBmbG9hdCB4ID0gcG9zaXRpb25bMF07XG5cdCAgICAgIGZsb2F0IHkgPSBwb3NpdGlvblsxXTtcblxuXHRcdFx0XHRyZXR1cm4gdmVjMihcblx0XHQgICAgICAyLjAgKiAoKHggLyBzdGFnZVdpZHRoKSAtIDAuNSksXG5cdFx0ICAgICAgLy8gaW52ZXJ0IHkgc2luY2Ugd2UgdGhpbmsgWzAsMF0gaXMgYm90dG9tIGxlZnQgaW4gcGl4ZWwgc3BhY2Vcblx0XHQgICAgICAtKDIuMCAqICgoeSAvIHN0YWdlSGVpZ2h0KSAtIDAuNSkpKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gaGVscGVyIGZ1bmN0aW9uIHRvIGhhbmRsZSBjdWJpYyBlYXNpbmcgKGNvcGllZCBmcm9tIGQzIGZvciBjb25zaXN0ZW5jeSlcblx0XHRcdC8vIG5vdGUgdGhlcmUgYXJlIHByZS1tYWRlIGVhc2luZyBmdW5jdGlvbnMgYXZhaWxhYmxlIHZpYSBnbHNsaWZ5LlxuXHRcdFx0ZmxvYXQgZWFzZUN1YmljSW5PdXQoZmxvYXQgdCkge1xuXHRcdFx0XHR0ICo9IDIuMDtcbiAgICAgICAgdCA9ICh0IDw9IDEuMCA/IHQgKiB0ICogdCA6ICh0IC09IDIuMCkgKiB0ICogdCArIDIuMCkgLyAyLjA7XG5cbiAgICAgICAgaWYgKHQgPiAxLjApIHtcbiAgICAgICAgICB0ID0gMS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHQ7XG5cdFx0XHR9XG5cblx0XHRcdHZvaWQgbWFpbigpIHtcblx0XHRcdFx0Z2xfUG9pbnRTaXplID0gcG9pbnRXaWR0aDtcblxuXHRcdFx0XHRmbG9hdCBkZWxheSA9IGRlbGF5QnlJbmRleCAqIGluZGV4O1xuXHQgICAgICBmbG9hdCB0O1xuXG5cdCAgICAgIC8vIGRyYXdpbmcgd2l0aG91dCBhbmltYXRpb24sIHNvIHNob3cgZW5kIHN0YXRlIGltbWVkaWF0ZWx5XG5cdCAgICAgIGlmIChkdXJhdGlvbiA9PSAwLjApIHtcblx0ICAgICAgICB0ID0gMS4wO1xuXG5cdCAgICAgIC8vIHN0aWxsIGRlbGF5aW5nIGJlZm9yZSBhbmltYXRpbmdcblx0ICAgICAgfSBlbHNlIGlmIChlbGFwc2VkIDwgZGVsYXkpIHtcblx0ICAgICAgICB0ID0gMC4wO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHQgPSBlYXNlQ3ViaWNJbk91dCgoZWxhcHNlZCAtIGRlbGF5KSAvIGR1cmF0aW9uKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIGludGVycG9sYXRlIHBvc2l0aW9uXG5cdCAgICAgIHZlYzIgcG9zaXRpb24gPSBtaXgocG9zaXRpb25TdGFydCwgcG9zaXRpb25FbmQsIHQpO1xuXG5cdCAgICAgIC8vIGFwcGx5IGFuIGFtYmllbnQgYW5pbWF0aW9uXG5cdFx0XHRcdC8vIGZsb2F0IGRpciA9IGluZGV4ID4gbnVtUG9pbnRzIC8gMi4wID8gMS4wIDogLTEuMDtcblx0ICAgICAgLy8gcG9zaXRpb25bMF0gKz0gYW5pbWF0aW9uUmFkaXVzICogY29zKCh0aWNrICsgaW5kZXgpICogZGlyKTtcblx0ICAgICAgLy8gcG9zaXRpb25bMV0gKz0gYW5pbWF0aW9uUmFkaXVzICogc2luKCh0aWNrICsgaW5kZXgpICogZGlyKTtcblxuXHQgICAgICAvLyBhYm92ZSB3ZSArIGluZGV4IHRvIG9mZnNldCBob3cgdGhleSBtb3ZlXG5cdCAgICAgIC8vIHdlIG11bHRpcGx5IGJ5IGRpciB0byBjaGFuZ2UgQ1cgdnMgQ0NXIGZvciBoYWxmXG5cblxuXHQgICAgICAvLyBpbnRlcnBvbGF0ZSBjb2xvclxuXHQgICAgICBmcmFnQ29sb3IgPSBtaXgoY29sb3JTdGFydCwgY29sb3JFbmQsIHQpO1xuXG5cdCAgICAgIC8vIHNjYWxlIHRvIG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzXG5cdFx0XHRcdC8vIGdsX1Bvc2l0aW9uIGlzIGEgc3BlY2lhbCB2YXJpYWJsZSB0aGF0IGhvbGRzIHRoZSBwb3NpdGlvbiBvZiBhIHZlcnRleFxuXHQgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQobm9ybWFsaXplQ29vcmRzKHBvc2l0aW9uKSwgMC4wLCAxLjApO1xuXHRcdFx0fVxuXHRcdFx0YCxcblxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICBwb3NpdGlvblN0YXJ0OiBwb2ludHMubWFwKGQgPT4gW2Quc3gsIGQuc3ldKSxcbiAgICAgICAgcG9zaXRpb25FbmQ6IHBvaW50cy5tYXAoZCA9PiBbZC50eCwgZC50eV0pLFxuICAgICAgICBjb2xvclN0YXJ0OiBwb2ludHMubWFwKGQgPT4gZC5jb2xvclN0YXJ0KSxcbiAgICAgICAgY29sb3JFbmQ6IHBvaW50cy5tYXAoZCA9PiBkLmNvbG9yRW5kKSxcbiAgICAgICAgaW5kZXg6IGQzLnJhbmdlKHBvaW50cy5sZW5ndGgpLFxuICAgICAgfSxcblxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgcG9pbnRXaWR0aDogcmVnbC5wcm9wKCdwb2ludFdpZHRoJyksXG4gICAgICAgIHN0YWdlV2lkdGg6IHJlZ2wucHJvcCgnc3RhZ2VXaWR0aCcpLFxuICAgICAgICBzdGFnZUhlaWdodDogcmVnbC5wcm9wKCdzdGFnZUhlaWdodCcpLFxuICAgICAgICBkZWxheUJ5SW5kZXg6IHJlZ2wucHJvcCgnZGVsYXlCeUluZGV4JyksXG4gICAgICAgIGR1cmF0aW9uOiByZWdsLnByb3AoJ2R1cmF0aW9uJyksXG4gICAgICAgIG51bVBvaW50czogbnVtUG9pbnRzLFxuICAgICAgICAvLyBhbmltYXRpb25SYWRpdXM6IDAsLy8gMTUuMCxcbiAgICAgICAgLy8gdGljazogKHJlZ2xwcm9wcykgPT4geyAvLyBpbmNyZWFzZSBtdWx0aXBsaWVyIGZvciBmYXN0ZXIgYW5pbWF0aW9uIHNwZWVkXG4gICAgICAgIC8vIFx0Ly8gY29uc29sZS5sb2cocmVnbHByb3BzKTtcbiAgICAgICAgLy8gXHQvLyByZXR1cm4gcmVnbHByb3BzLnRpY2sgLyA1MDtcbiAgICAgICAgLy8gXHRyZXR1cm4gMDsgLy8gZGlzYWJsZSBhbWJpZW50IGFuaW1hdGlvblxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgcHJvcCBzdGFydFRpbWUgKGkuZS4gdGltZSBlbGFwc2VkKVxuICAgICAgICBlbGFwc2VkOiAoeyB0aW1lIH0sIHsgc3RhcnRUaW1lID0gMCB9KSA9PiAodGltZSAtIHN0YXJ0VGltZSkgKiAxMDAwLFxuICAgICAgfSxcblxuICAgICAgY291bnQ6IHBvaW50cy5sZW5ndGgsXG4gICAgICBwcmltaXRpdmU6ICdwb2ludHMnLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRyYXdQb2ludHM7XG4gIH1cblxuICAvLyBmdW5jdGlvbiB0byBzdGFydCBhbmltYXRpb24gbG9vcCAobm90ZTogdGltZSBpcyBpbiBzZWNvbmRzKVxuICBmdW5jdGlvbiBhbmltYXRlKGxheW91dCwgcG9pbnRzKSB7XG4gICAgY29uc29sZS5sb2coJ2FuaW1hdGluZyB3aXRoIG5ldyBsYXlvdXQnKTtcbiAgICAvLyBtYWtlIHByZXZpb3VzIGVuZCB0aGUgbmV3IGJlZ2lubmluZ1xuICAgIHBvaW50cy5mb3JFYWNoKGQgPT4ge1xuICAgICAgZC5zeCA9IGQudHg7XG4gICAgICBkLnN5ID0gZC50eTtcbiAgICAgIGQuY29sb3JTdGFydCA9IGQuY29sb3JFbmQ7XG4gICAgfSk7XG5cbiAgICAvLyBsYXlvdXQgcG9pbnRzXG4gICAgbGF5b3V0KHBvaW50cyk7XG5cbiAgICAvLyBjb3B5IGxheW91dCB4IHkgdG8gZW5kIHBvc2l0aW9uc1xuICAgIGNvbnN0IGNvbG9yU2NhbGUgPSBjb2xvclNjYWxlc1tjdXJyZW50Q29sb3JTY2FsZV07XG4gICAgcG9pbnRzLmZvckVhY2goKGQsIGkpID0+IHtcbiAgICAgIGQudHggPSBkLng7XG4gICAgICBkLnR5ID0gZC55O1xuICAgICAgLy8gZC5jb2xvckVuZCA9IGNvbG9yU2NhbGUoaSAvIHBvaW50cy5sZW5ndGgpXG4gICAgICBkLmNvbG9yRW5kID0gZC5jb2xvcjtcbiAgICB9KTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgcmVnbCBmdW5jdGlvbiB3aXRoIHRoZSBuZXcgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICBjb25zdCBkcmF3UG9pbnRzID0gY3JlYXRlRHJhd1BvaW50cyhwb2ludHMpO1xuXG4gICAgLy8gc3RhcnQgYW4gYW5pbWF0aW9uIGxvb3BcbiAgICBsZXQgc3RhcnRUaW1lID0gbnVsbDsgLy8gaW4gc2Vjb25kc1xuICAgIGNvbnN0IGZyYW1lTG9vcCA9IHJlZ2wuZnJhbWUoKHsgdGltZSB9KSA9PiB7XG4gICAgICAvLyBrZWVwIHRyYWNrIG9mIHN0YXJ0IHRpbWUgc28gd2UgY2FuIGdldCB0aW1lIGVsYXBzZWRcbiAgICAgIC8vIHRoaXMgaXMgaW1wb3J0YW50IHNpbmNlIHRpbWUgZG9lc24ndCByZXNldCB3aGVuIHN0YXJ0aW5nIG5ldyBhbmltYXRpb25zXG4gICAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0VGltZSA9IHRpbWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFyIHRoZSBidWZmZXJcbiAgICAgIHJlZ2wuY2xlYXIoe1xuICAgICAgICAvLyBiYWNrZ3JvdW5kIGNvbG9yIChibGFjaylcbiAgICAgICAgY29sb3I6IFswLCAwLCAwLCAxXSxcbiAgICAgICAgZGVwdGg6IDEsXG4gICAgICB9KTtcblxuICAgICAgLy8gZHJhdyB0aGUgcG9pbnRzIHVzaW5nIG91ciBjcmVhdGVkIHJlZ2wgZnVuY1xuICAgICAgLy8gbm90ZSB0aGF0IHRoZSBhcmd1bWVudHMgYXJlIGF2YWlsYWJsZSB2aWEgYHJlZ2wucHJvcGAuXG4gICAgICBkcmF3UG9pbnRzKHtcbiAgICAgICAgcG9pbnRXaWR0aCxcbiAgICAgICAgc3RhZ2VXaWR0aDogd2lkdGgsXG4gICAgICAgIHN0YWdlSGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBkZWxheUJ5SW5kZXgsXG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBob3cgbG9uZyB0byBzdGF5IGF0IGEgZmluYWwgZnJhbWUgYmVmb3JlIGFuaW1hdGluZyBhZ2FpbiAoaW4gc2Vjb25kcylcbiAgICAgIGNvbnN0IGRlbGF5QXRFbmQgPSAwLjE7XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgZXhjZWVkZWQgdGhlIG1heGltdW0gZHVyYXRpb24sIG1vdmUgb24gdG8gdGhlIG5leHQgYW5pbWF0aW9uXG4gICAgICBpZiAodGltZSAtIHN0YXJ0VGltZSA+IG1heER1cmF0aW9uIC8gMTAwMCArIGRlbGF5QXRFbmQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2RvbmUgYW5pbWF0aW5nLCBtb3ZpbmcgdG8gbmV4dCBsYXlvdXQnKTtcblxuICAgICAgICBmcmFtZUxvb3AuY2FuY2VsKCk7XG4gICAgICAgIGN1cnJlbnRMYXlvdXQgPSAoY3VycmVudExheW91dCArIDEpICUgbGF5b3V0cy5sZW5ndGg7XG4gICAgICAgIGN1cnJlbnRDb2xvclNjYWxlID0gKGN1cnJlbnRDb2xvclNjYWxlICsgMSkgJSBjb2xvclNjYWxlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gd2hlbiByZXN0YXJ0aW5nIGF0IHRoZSBiZWdpbm5pbmcsIGNvbWUgYmFjayBmcm9tIHRoZSBtaWRkbGUgYWdhaW5cbiAgICAgICAgaWYgKGN1cnJlbnRMYXlvdXQgPT09IDApIHtcbiAgICAgICAgICBwb2ludHMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgICAgICAgZC50eCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgIGQudHkgPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgZC5jb2xvckVuZCA9IFswLCAwLCAwXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuaW1hdGUobGF5b3V0c1tjdXJyZW50TGF5b3V0XSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBpbml0aWFsIHNldCBvZiBwb2ludHNcbiAgY29uc3QgcG9pbnRzID0gZDMucmFuZ2UobnVtUG9pbnRzKS5tYXAoZCA9PiAoe30pKTtcblxuICBwb2ludHMuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgIGQudHggPSB3aWR0aCAvIDI7XG4gICAgZC50eSA9IGhlaWdodCAvIDI7XG4gICAgZC5jb2xvckVuZCA9IFswLCAwLCAwXTtcbiAgfSk7XG5cbiAgLy8gc3RhcnQgYW5pbWF0aW9uIGxvb3BcbiAgYW5pbWF0ZShsYXlvdXRzW2N1cnJlbnRMYXlvdXRdLCBwb2ludHMpO1xufVxuXG5sb2FkRGF0YSh3aWR0aCwgaGVpZ2h0KS50aGVuKCh7IGNpdGllc0RhdGEsIGltZ0RhdGEgfSkgPT4ge1xuICBjb25zb2xlLmxvZygnZGF0YSBoYXMgbG9hZGVkLiBpbml0aWFsaXppbmcgcmVnbC4uLicpO1xuXG4gIC8vIGluaXRpYWxpemUgcmVnbFxuICBjcmVhdGVSRUdMKHtcbiAgICAvLyBjYWxsYmFjayB3aGVuIHJlZ2wgaXMgaW5pdGlhbGl6ZWRcbiAgICBvbkRvbmU6IChlcnIsIHJlZ2wpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIHJlZ2wnLCBlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYWluKHJlZ2wsIGNpdGllc0RhdGEsIGltZ0RhdGEpO1xuICAgIH0sXG4gIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc2NyaXB0LmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFrRkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZEE7QUFDQTtBQWdCQTtBQUNBO0FBdEhBO0FBQ0E7QUF3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")}]);